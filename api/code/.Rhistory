PC2 = prcomp(t(count_data_subset))$x[,2],
cluster = as.factor(kmeans_result$cluster),
sample_info)
# Plot the K-means clusters
kmeans_plot <- ggplot(kmeans_df, aes(x = PC1, y = PC2, color = cluster, label = row.names(sample_info))) +
geom_point(size = 3) +
geom_text(hjust = 0, vjust = 1) +
labs(title = title, x = "PC1", y = "PC2") +
theme_minimal()
print(kmeans_plot)
}
# Function to generate boxplot
plot_boxplot <- function(count_data_subset, sample_info, title = "Boxplot") {
group_colors <- as.factor(sample_info$group)
palette(c("#1B9E77", "#D95F02", "#7570B3"))
boxplot(count_data_subset, outline = FALSE, las = 2,
main = title,
xlab = "Samples", ylab = "Expression levels",
col = palette()[group_colors],
names = row.names(sample_info))
}
# Function to plot the P-value distribution
plot_pvalue_distribution <- function(topTable1, contrast_name) {
hist(topTable1$adj.P.Val,
col = "#B32424",
border = "white",
xlab = "Adjusted P-value",
ylab = "Number of Genes",
main = paste("Adjusted P-value Distribution: ", contrast_name))
}
# Function to generate Volcano Plot
plot_volcano <- function(topTable1, title = "Volcano Plot") {
# Mark the regulated genes
UP_Genes <- topTable1[topTable1$logFC > 1 & topTable1$adj.P.Val < 0.05, ]
Down_Genes <- topTable1[topTable1$logFC < -1 & topTable1$adj.P.Val < 0.05, ]
combined_data_adj <- rbind(
transform(UP_Genes, Regulation = "Upregulated"),
transform(Down_Genes, Regulation = "Downregulated"),
transform(topTable1[!(rownames(topTable1) %in% rownames(UP_Genes) | rownames(topTable1) %in% rownames(Down_Genes)),], Regulation = "Not Significant")
)
# Create volcano plot
volcano_plot <- ggplot(combined_data_adj, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point(aes(color = Regulation), size = 2, alpha = 0.7) +
geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "red") +
geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
labs(
title = title,
x = "Log2 Fold Change",
y = "-log10(adj.P-Value)",
color = "Regulation"
) +
scale_color_manual(values = c("Upregulated" = "red", "Downregulated" = "blue", "Not Significant" = "grey")) +
theme_minimal()
print(volcano_plot)
}
# Function to generate Volcano Plot with Highlighted Genes
plot_volcano_with_highlight <- function(topTable1, highlight_data, gene_ids, title = "Volcano Plot with Highlights") {
# Mark the regulated genes
UP_Genes <- topTable1[topTable1$logFC > 1 & topTable1$adj.P.Val < 0.05, ]
Down_Genes <- topTable1[topTable1$logFC < -1 & topTable1$adj.P.Val < 0.05, ]
combined_data_adj <- rbind(
transform(UP_Genes, Regulation = "Upregulated"),
transform(Down_Genes, Regulation = "Downregulated"),
transform(topTable1[!(rownames(topTable1) %in% rownames(UP_Genes) | rownames(topTable1) %in% rownames(Down_Genes)),], Regulation = "Not Significant")
)
# Create volcano plot
volcano_plot <- ggplot(combined_data_adj, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point(aes(color = Regulation), size = 2, alpha = 0.7) +
geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "red") +
geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
labs(
title = title,
x = "Log2 Fold Change",
y = "-log10(adj.P-Value)",
color = "Regulation"
) +
scale_color_manual(values = c("Upregulated" = "red", "Downregulated" = "blue", "Not Significant" = "grey")) +
theme_minimal()
# Highlight specific genes by circling them
if (nrow(highlight_data) > 0) {
# Draw the circle around the highlighted points
volcano_plot <- volcano_plot +
geom_point(data = highlight_data, aes(x = logFC, y = -log10(adj.P.Val)), color = "black", size = 4, shape = 1, stroke = 1.5) + # Circle
geom_text(data = highlight_data, aes(x = logFC, y = -log10(adj.P.Val), label = gene_ids), vjust = -1, color = "black")
}
print(volcano_plot)
}
# Function to detect and remove outliers
remove_outliers <- function(count_data_subset, sample_info) {
# Display the available sample names
cat("Available sample IDs:\n")
cat(row.names(sample_info), sep = ", ")
# Prompt the user to enter outliers
outliers_input <- readline(prompt = "\nEnter the sample IDs to remove, separated by commas: ")
outliers <- unlist(strsplit(outliers_input, ","))
outliers <- trimws(outliers)  # Trim any leading/trailing spaces
# Check if the entered sample IDs are valid
invalid_outliers <- outliers[!(outliers %in% row.names(sample_info))]
if (length(invalid_outliers) > 0) {
stop(paste("Invalid sample IDs entered:", paste(invalid_outliers, collapse = ", ")))
}
if (length(outliers) > 0) {
count_data_clean <- count_data_subset[, !colnames(count_data_subset) %in% outliers]
# count_data_normalized_clean <- count_data_normalized[, !colnames(count_data_normalized) %in% outliers]
count_data_clean <- complete_cases_fx(count_data_clean)
count_data_normalized_clean <- normalize_data(count_data_clean)
sample_info_clean <- sample_info[!row.names(sample_info) %in% outliers, , drop = FALSE]
return(list(count_data_clean = count_data_clean,
count_data_normalized_clean = count_data_normalized_clean,
sample_info_clean = sample_info_clean))
}
return(NULL)
}
# Differential Expression Function
perform_differential_expression <- function(count_data_subset, sample_info, group_col = "group") {
group <- sample_info[, 1]
groups <- factor(group)
design <- model.matrix(~0 + groups)
colnames(design) <- levels(groups)
fit <- lmFit(count_data_subset, design)
condition <- unique(group)
# Display the available conditions (reference options)
cat("Available conditions:\n")
cat(condition, sep = ", ")
# Ask the user to input the reference condition
Reference <- readline(prompt = "\nEnter the reference condition: ")
# Check if the entered reference condition is valid
if (!(Reference %in% condition)) {
stop("Invalid reference condition. Please enter one of the listed conditions.")
}
# Select the treatment condition(s)
Treatment <- condition[condition != Reference]
for (treat in Treatment) {
cts <- paste(treat, Reference, sep = "-")
message("Contrast: ", cts)
cont.matrix <- makeContrasts(contrasts = cts, levels = design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
#resLFC
topTable1 <- topTable(fit2, adjust = "fdr", number = Inf)
write.csv(topTable1, "LFC.csv")
# Call function to plot adjusted P-value distribution
plot_pvalue_distribution(topTable1, contrast_name = cts)
# Mark the regulated genes
UP_Genes <- topTable1[topTable1$logFC > 1 & topTable1$adj.P.Val < 0.05, ]
Down_Genes <- topTable1[topTable1$logFC < -1 & topTable1$adj.P.Val < 0.05, ]
message("Number of Upregulated Genes (logFC > 1, adj.P.Val < 0.05): ", nrow(UP_Genes))
message("Number of Downregulated Genes (logFC < -1, adj.P.Val < 0.05): ", nrow(Down_Genes))
up_file <- paste0("Upregulated_Genes_", treat, "_vs_", Reference, ".csv")
down_file <- paste0("Downregulated_Genes_", treat, "_vs_", Reference, ".csv")
write.csv(UP_Genes, up_file)
write.csv(Down_Genes, down_file)
# Plot volcano plot for each contrast
plot_volcano(topTable1, title = paste("Volcano Plot: ", treat, " vs ", Reference))
# Ask the user if they want to highlight any specific gene(s)
highlight_genes <- readline(prompt = "Highlight any specific gene(s)? Enter the gene IDs separated by commas, or press Enter to skip: ")
if (nchar(highlight_genes) > 0) {
gene_ids <- trimws(unlist(strsplit(highlight_genes, ",")))
# Highlight the specified genes in the volcano plot
highlight_data <- topTable1[rownames(topTable1) %in% gene_ids, ]
if (nrow(highlight_data) > 0) {
plot_volcano_with_highlight(topTable1, highlight_data, gene_ids, title = paste("Highlighted Volcano Plot: ", treat, " vs ", Reference))
} else {
message("None of the entered gene IDs were found in the data.")
}
}
}
}
# load and install libraries
load_and_install_libraries()
#Load data
data_files <- load_and_preprocess_data("Full_Expression_11234.csv", "Metadata_11234_F.csv")
count_data_subset <- data_files$count_data_subset
sample_info <- data_files$sample_info
count_data_subset_cc <- complete_cases_fx(count_data_subset)
# Apply normalization
count_data_normalized <- normalize_data(count_data_subset_cc)
#write.csv(count_data_normalized, "4vs8_clean_normalized.csv")
# Generate figures before normalization
#Umap
plot_umap(count_data_subset_cc, sample_info, title = "UMAP Plot (Before Normalization)")
plot_umap(count_data_normalized, sample_info, title = "UMAP Plot (After Normalization)")
#t-SNE
plot_tsne(count_data_subset_cc, sample_info, title = "t-SNE Plot (Before Normalization)")
plot_tsne(count_data_normalized, sample_info, title = "t-SNE Plot (After Normalization)")
#PCA
plot_pca(count_data_subset_cc, sample_info, title = "PCA Plot (Before Normalization)")
plot_pca(count_data_normalized, sample_info, title = "PCA Plot (After Normalization)")
#Phylogenetic tree
plot_phylo_tree(count_data_subset_cc, sample_info, title = "Phylogenetic Tree (Before Normalization)")
plot_phylo_tree(count_data_normalized, sample_info, title = "Phylogenetic Tree (After Normalization)")
#K-Means Clustering
plot_kmeans(count_data_subset_cc, sample_info, num_clusters = 2, title = "K-Means Clustering (Before Normalization)")
plot_kmeans(count_data_normalized, sample_info, num_clusters = 2, title = "K-Means Clustering (After Normalization)")
#Boxplot
plot_boxplot(count_data_subset_cc, sample_info, title = "Boxplot (Before Normalization)")
plot_boxplot(count_data_normalized, sample_info, title = "Boxplot (After Normalization)")
# Remove outliers
outlier_removal <- remove_outliers(count_data_subset, sample_info)
# Remove outliers
outlier_removal <- remove_outliers(count_data_subset, sample_info)
if (!is.null(outlier_removal)) {
count_data_subset_clean <- outlier_removal$count_data_clean
# write.csv(count_data_subset_clean, "4vs8_clean.csv")
sample_info_clean <- outlier_removal$sample_info_clean
count_data_subset_clean_normalized <- outlier_removal$count_data_normalized_clean
#Umap
plot_umap(count_data_subset_clean, sample_info_clean, title = "UMAP Plot (After Outlier Removal)")
plot_umap(count_data_subset_clean_normalized, sample_info_clean, title = "UMAP Plot (After Outlier Removal(Normalized))")
#t-SNE
plot_tsne(count_data_subset_clean, sample_info_clean, title = "t-SNE Plot (After Outlier Removal)")
plot_tsne(count_data_subset_clean_normalized, sample_info_clean, title = "t-SNE Plot (After Outlier Removal(Normalized))")
#PCA
plot_pca(count_data_subset_clean, sample_info_clean, title = "PCA Plot (After Outlier Removal)")
plot_pca(count_data_subset_clean_normalized, sample_info_clean, title = "PCA Plot (After Outlier Removal(Normalized))")
#Phylogenetic Tree
plot_phylo_tree(count_data_subset_clean,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal)")
plot_phylo_tree(count_data_subset_clean_normalized,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal(Normalized))")
# Boxplot
plot_boxplot(count_data_subset_clean, sample_info_clean, title = "Boxplot (After Outlier Removal)")
plot_boxplot(count_data_subset_clean_normalized, sample_info_clean, title = "Boxplot (After Outlier Removal(Normalized))")
perform_differential_expression(count_data_subset_clean_normalized, sample_info_clean)
} else {
perform_differential_expression(count_data_normalized, sample_info)
}
View(count_data_normalized)
# Remove outliers
outlier_removal <- remove_outliers(count_data_subset, sample_info)
if (!is.null(outlier_removal)) {
count_data_subset_clean <- outlier_removal$count_data_clean
# write.csv(count_data_subset_clean, "4vs8_clean.csv")
sample_info_clean <- outlier_removal$sample_info_clean
count_data_subset_clean_normalized <- outlier_removal$count_data_normalized_clean
#Umap
plot_umap(count_data_subset_clean, sample_info_clean, title = "UMAP Plot (After Outlier Removal)")
plot_umap(count_data_subset_clean_normalized, sample_info_clean, title = "UMAP Plot (After Outlier Removal(Normalized))")
#t-SNE
plot_tsne(count_data_subset_clean, sample_info_clean, title = "t-SNE Plot (After Outlier Removal)")
plot_tsne(count_data_subset_clean_normalized, sample_info_clean, title = "t-SNE Plot (After Outlier Removal(Normalized))")
#PCA
plot_pca(count_data_subset_clean, sample_info_clean, title = "PCA Plot (After Outlier Removal)")
plot_pca(count_data_subset_clean_normalized, sample_info_clean, title = "PCA Plot (After Outlier Removal(Normalized))")
#Phylogenetic Tree
plot_phylo_tree(count_data_subset_clean,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal)")
plot_phylo_tree(count_data_subset_clean_normalized,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal(Normalized))")
# Boxplot
plot_boxplot(count_data_subset_clean, sample_info_clean, title = "Boxplot (After Outlier Removal)")
plot_boxplot(count_data_subset_clean_normalized, sample_info_clean, title = "Boxplot (After Outlier Removal(Normalized))")
perform_differential_expression(count_data_subset_clean_normalized, sample_info_clean)
} else {
perform_differential_expression(count_data_normalized, sample_info)
}
View(count_data_subset_clean_normalized)
View(count_data_subset_clean_normalized)
View(count_data_normalized)
View(count_data_normalized)
View(count_data_subset_clean_normalized)
View(count_data_subset_clean_normalized)
View(count_data_normalized)
View(count_data_normalized)
View(count_data_subset_clean_normalized)
View(count_data_subset_clean_normalized)
View(count_data_normalized)
View(count_data_normalized)
# Remove outliers
outlier_removal <- remove_outliers(count_data_subset, sample_info)
# Remove outliers
outlier_removal <- remove_outliers(count_data_subset, sample_info)
if (!is.null(outlier_removal)) {
count_data_subset_clean <- outlier_removal$count_data_clean
# write.csv(count_data_subset_clean, "4vs8_clean.csv")
sample_info_clean <- outlier_removal$sample_info_clean
count_data_subset_clean_normalized <- outlier_removal$count_data_normalized_clean
#Umap
plot_umap(count_data_subset_clean, sample_info_clean, title = "UMAP Plot (After Outlier Removal)")
plot_umap(count_data_subset_clean_normalized, sample_info_clean, title = "UMAP Plot (After Outlier Removal(Normalized))")
#t-SNE
plot_tsne(count_data_subset_clean, sample_info_clean, title = "t-SNE Plot (After Outlier Removal)")
plot_tsne(count_data_subset_clean_normalized, sample_info_clean, title = "t-SNE Plot (After Outlier Removal(Normalized))")
#PCA
plot_pca(count_data_subset_clean, sample_info_clean, title = "PCA Plot (After Outlier Removal)")
plot_pca(count_data_subset_clean_normalized, sample_info_clean, title = "PCA Plot (After Outlier Removal(Normalized))")
#Phylogenetic Tree
plot_phylo_tree(count_data_subset_clean,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal)")
plot_phylo_tree(count_data_subset_clean_normalized,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal(Normalized))")
# Boxplot
plot_boxplot(count_data_subset_clean, sample_info_clean, title = "Boxplot (After Outlier Removal)")
plot_boxplot(count_data_subset_clean_normalized, sample_info_clean, title = "Boxplot (After Outlier Removal(Normalized))")
perform_differential_expression(count_data_subset_clean_normalized, sample_info_clean)
} else {
perform_differential_expression(count_data_normalized, sample_info)
}
perform_differential_expression(count_data_subset_clean_normalized, sample_info_clean)
group <- sample_info[, 1]
groups <- factor(group)
design <- model.matrix(~0 + groups)
colnames(design) <- levels(groups)
fit <- lmFit(count_data_subset, design)
condition <- unique(group)
# Display the available conditions (reference options)
cat("Available conditions:\n")
cat(condition, sep = ", ")
# Ask the user to input the reference condition
Reference <- readline(prompt = "\nEnter the reference condition: ")
if (!is.null(outlier_removal)) {
count_data_subset_clean <- outlier_removal$count_data_clean
# write.csv(count_data_subset_clean, "4vs8_clean.csv")
sample_info_clean <- outlier_removal$sample_info_clean
count_data_subset_clean_normalized <- outlier_removal$count_data_normalized_clean
#Umap
plot_umap(count_data_subset_clean, sample_info_clean, title = "UMAP Plot (After Outlier Removal)")
plot_umap(count_data_subset_clean_normalized, sample_info_clean, title = "UMAP Plot (After Outlier Removal(Normalized))")
#t-SNE
plot_tsne(count_data_subset_clean, sample_info_clean, title = "t-SNE Plot (After Outlier Removal)")
plot_tsne(count_data_subset_clean_normalized, sample_info_clean, title = "t-SNE Plot (After Outlier Removal(Normalized))")
#PCA
plot_pca(count_data_subset_clean, sample_info_clean, title = "PCA Plot (After Outlier Removal)")
plot_pca(count_data_subset_clean_normalized, sample_info_clean, title = "PCA Plot (After Outlier Removal(Normalized))")
#Phylogenetic Tree
plot_phylo_tree(count_data_subset_clean,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal)")
plot_phylo_tree(count_data_subset_clean_normalized,sample_info_clean, title = "Phylogenetic Tree (After Outlier Removal(Normalized))")
# Boxplot
plot_boxplot(count_data_subset_clean, sample_info_clean, title = "Boxplot (After Outlier Removal)")
plot_boxplot(count_data_subset_clean_normalized, sample_info_clean, title = "Boxplot (After Outlier Removal(Normalized))")
perform_differential_expression(count_data_subset_clean_normalized, sample_info_clean)
} else {
perform_differential_expression(count_data_normalized, sample_info)
}
plot_volcano_with_highlight(topTable1, highlight_data, gene_ids, title = paste("Highlighted Volcano Plot: ", treat, " vs ", Reference))
# Expression Data
# load the count data
count_data <- read.csv("count_data.csv", header = TRUE, row.names = 1)
# Metadata
# load the sample info
sample_info <- read.csv("meta_data.csv", header = TRUE, row.names = 1)
# Ensure the number of samples match
if (ncol(count_data) != nrow(sample_info)) {
stop("Number of samples in count_data and sample_info do not match!")
}
# Convert the Col name of user to "Treatment"
colnames(sample_info)[colnames(sample_info) == colnames(sample_info)] <- "Treatment"
# Convert Condition to factor
sample_info$Treatment <- factor(sample_info$Treatment)
# Quality Control: detect outlier genes
library(WGCNA)
gsg <- goodSamplesGenes(t(count_data)) # check the data format
summary(gsg)
# Remove outlier genes
data <- count_data[gsg$goodGenes == TRUE,]
# Check for NA or Infinite values
summary(data)
is.na(data)
data[is.na(data)] <- 0
# Replacing Infinite Values
data_list <- as.list(data)
for (name in names(data_list)) {
data_list[[name]][is.infinite(data_list[[name]])] <- 0
}
data <- as.data.frame(data_list)
# Verify no NA or Infinite values remain
summary(data)
# Remove non-numeric columns for PCA
# Remove the gene ID column
data_numeric <- data[, sapply(data, is.numeric)]
# Perform PCA
pca <- prcomp(t(data_numeric))
# View the PCA results
summary(pca)
# Prepare PCA data for plotting
pca.dat <- as.data.frame(pca$x)
pca.var <- pca$sdev^2
pca.var.percent <- round(pca.var / sum(pca.var) * 100, digits = 2)
# Merge PCA data with metadata
pca.dat <- cbind(pca.dat, sample_info)
library(ggplot2)
# Plot PCA with metadata groups
ggplot(pca.dat, aes(PC1, PC2, color = Treatment)) +
geom_point() +
geom_text(aes(label = rownames(pca.dat)), hjust = 0, vjust = 1) +
labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
y = paste0('PC2: ', pca.var.percent[2], ' %')) +
theme_minimal() +
theme(legend.title = element_blank())
# Load libraries
library(umap)
# Set random seed for reproducibility
set.seed(123)
# Perform UMAP dimensionality reduction
umap_result <- umap(t(data_numeric), n_neighbors = 5, min_dist = 0.5)
# Extract UMAP coordinates and combine with metadata
umap_df <- data.frame(
X1 = umap_result$layout[, 1],  # UMAP component 1
X2 = umap_result$layout[, 2],  # UMAP component 2
sample_info
)
library(ggplot2)
# Plot using ggplot2
ggplot(umap_df, aes(x = X1, y = X2, color = Treatment)) +
geom_text(aes(label = rownames(sample_info)), hjust = 0, vjust = 1) +
geom_point(size = 3) +
labs(title = "UMAP",
x = "UMAP 1", y = "UMAP 2") +
theme_minimal()
library(Rtsne)
set.seed(123)
# Perform t-SNE
tsne_result <- Rtsne(t(data_numeric), dims=2, perplexity=3, verbose=TRUE, max_iter=500)
# Create a data frame for plotting
tsne_data <- data.frame(
X = tsne_result$Y[,1],
Y = tsne_result$Y[,2],
sample_info
)
# Plot the t-SNE results using ggplot2
ggplot(tsne_data, aes(x = X, y = Y, color = Treatment, label = rownames(sample_info))) +
geom_point(size = 3) +
geom_text(aes(label = rownames(sample_info)), hjust = 0, vjust = 1) +
theme_minimal() +
ggtitle("t-SNE Plot") +
xlab("t-SNE 1") +
ylab("t-SNE 2") +
theme_minimal()
# Detect outlier samples using hierarchical clustering
htree <- hclust(dist(t(data_numeric)), method = "average")
# Convert labels to factors or unique numeric indices for colors
label_colors <- as.numeric(factor(sample_info$Treatment))
# Plot the dendrogram with colored labels
plot(htree, labels = rownames(sample_info), main = "Hierarchical Clustering Dendrogram", col = label_colors)
# Convert non-integer values to integers in count data
data <- round(data)
head(data)
# Create a new count data object
new_data <- as.matrix(data)
head(new_data)
# Display dimensions for verification
cat("Dimensions of data:", dim(data), "\n")
cat("Dimensions of new_data:", dim(new_data), "\n")
cat("Dimensions of sample_info:", dim(sample_info), "\n")
library(DESeq2)
# Display dimensions for verification
cat("Dimensions of data:", dim(data), "\n")
cat("Dimensions of new_data:", dim(new_data), "\n")
cat("Dimensions of sample_info:", dim(sample_info), "\n")
library(DESeq2)
# Generate the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = new_data, colData = sample_info, design = ~ Treatment)
# Set the factor levels for the Treatment column based on unique values
condition <- unique(sample_info$Treatment)
dds$Treatment <- factor(dds$Treatment, levels = condition)
# Set the factor levels for the Treatment column based on unique values
condition <- unique(sample_info$Treatment)
dds$Treatment <- factor(dds$Treatment, levels = condition)
# Filter genes with low counts (less than 75% of sample number)
threshold <- round(dim(sample_info)[1] * 0.70)
keep <- rowSums(counts(dds)) >= threshold
dds <- dds[keep,]
# Perform DESeq2 analysis
dds <- DESeq(dds)
# save the normalized counts
normalize_counts <- counts(dds,normalized=TRUE)
head(normalize_counts)
dim(normalize_counts)
write.csv(normalize_counts,"Normalized_Count_Data.csv")
# Log2 transformation for count data
count_matrix <- counts(dds) + 1  # Adding 1 to avoid log(0)
log2_count_matrix <- log2(count_matrix)
boxplot(log2_count_matrix, outline = FALSE, main = "Boxplot of Log2-transformed Count Data",
xlab = "Sample Name",
ylab = "Log2-transformed Counts")
# Log2 transformation for normalized count data
normalized_counts <- counts(dds, normalized = TRUE)
log2_normalized_counts <- log2(normalized_counts + 1)  # Adding 1 to avoid log(0)
boxplot(log2_normalized_counts, outline = FALSE,
main = "Boxplot of Log2-transformed Normalized Count Data",
xlab = "Sample Name",
ylab = "Log2-transformed Counts")
condition <- as.data.frame(condition)
print(condition)
print(condition)
print(condition)
# condition
# 1                    mock
# 2 MPXV_clade_IIa_infected
# 3 MPXV_clade_IIb_infected
# 4   MPXV_clade_I_infected
as.character(condition[2,])
"kuddus"
# Ensure the reference level is a character string
ref_level <- as.character(condition[2,]) #User selection
# set the reference/ control for the treatment factor
dds$Treatment <- relevel(dds$Treatment, ref = ref_level)# User input ref = "....."
# Perform DESeq2 analysis
dds <- DESeq(dds)
# Identify available coefficient names
coeff_names <- as.data.frame(resultsNames(dds))
# Print the coefficient names
print(coeff_names)
X <- coeff_names[2,]
resLFC <- lfcShrink(dds, coef =X  , type = "apeglm")
#change resLFC to a dataframe
resLFC <- as.data.frame(resLFC)
# create histogram plot of p-values
hist(resLFC$padj, breaks=seq(0, 1, length = 21), col = "grey", border = "white",
xlab = "", ylab = "", main = "Frequencies of padj-values")
summary(resLFC)
summary(resLFC)
# Upregulated genes
Upregulated <- resLFC[resLFC$log2FoldChange > 1 & resLFC$padj < 0.05, ]
# Print the coefficient names
print(coeff_names)
X <- coeff_names[2,]
X
